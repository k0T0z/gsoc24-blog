<!DOCTYPE html>
<html lang="">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/gsoc24-blog/assets/css/style.css">
<title>Google Summer of Code 2024 Week 6: The Rush Summer</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Google Summer of Code 2024 Week 6: The Rush Summer | k0T0z</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Google Summer of Code 2024 Week 6: The Rush Summer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning." />
<meta property="og:description" content="This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning." />
<link rel="canonical" href="https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html" />
<meta property="og:url" content="https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html" />
<meta property="og:site_name" content="k0T0z" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-06-30T21:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Google Summer of Code 2024 Week 6: The Rush Summer" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-06-30T21:00:00+00:00","datePublished":"2024-06-30T21:00:00+00:00","description":"This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning.","headline":"Google Summer of Code 2024 Week 6: The Rush Summer","mainEntityOfPage":{"@type":"WebPage","@id":"https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html"},"url":"https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/gsoc24-blog/assets/js/darkmode.js"></script>

</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header ">
      <div class="about-title">
      <a href="/gsoc24-blog/">
        
        <img src="/gsoc24-blog/assets/portfolio.png" alt="Saif Kandil" />
        
      </a>
      <h2 id="title">
        <a href="/gsoc24-blog/">Saif Kandil</a>
      </h2>
      </div><p class="tagline">Just a place for me to dump my thoughts about my Google Summer of Code 2024 project</p></div>
      
      <ul class="social about-footer "><a href="https://github.com/k0T0z" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a></ul><p class="about-footer ">&copy;
        2025</p><div class="about-footer ">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html">
    <h2 class="post-title">Google Summer of Code 2024 Week 6: The Rush Summer</h2>
  </a>
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Jun 30, 2024</div><ul class="post-categories"><li>blog</li></ul></div>
  <div class="post">
    <p>This blog post is related to my Google Summer of Code 2024 project: <a href="https://summerofcode.withgoogle.com/programs/2024/projects/wYTZuQbA">Procedural Fragment Shader Generation Using Classic Machine Learning</a>.</p>

<h2 id="enigma-and-google-protobuf">ENIGMA and Google Protobuf</h2>

<p>ENIGMA relies on Protobuf for various functionalities. RGM is structured as a Model-View-Controller (MVC) application, where each UI component of RGM is represented as part of a Protobuf message. This approach is also how ENIGMA handles the serialization and deserialization of its project files.</p>

<blockquote>
  <p>Josh — 01/07/2024 at 08:14</p>
</blockquote>

<blockquote>
  <p>you can eliminate a lot of that boilerplate using proto, @Saif
in fact, I recommend it, as you’ll need proto on hand to serialize to EGM etc</p>
</blockquote>

<blockquote>
  <p>add_node is a great example
of boilerplate, I mean; literally that is a function that protobuf would generate
check out the other resource messages
just search RGM for proto files</p>
</blockquote>

<blockquote>
  <p>Josh — 01/07/2024 at 09:25</p>
</blockquote>

<blockquote>
  <p>I suspect some of what I’ve written will still be necessary, but I suggest you try writing these node classes as protobuf messages and see where that gets you</p>
</blockquote>

<blockquote>
  <p>proto should save you a lot of effort here</p>
</blockquote>

<blockquote>
  <p>proto is just what C++ classes should look like</p>
</blockquote>

<blockquote>
  <p>well, sorry; as a storage layer, proto is certainly not what C++ classes should look like
but in terms of the features that a proto message offers….
there is absolutely no reason a modern programming language should not offer these features for its classes
proto just lets you do things like serialize and deserialize, use reflection, etc</p>
</blockquote>

<h2 id="the-ai-agent-phases">The AI Agent Phases</h2>

<p>When we reach the machine learning component, there are three main phases to consider:</p>

<ol>
  <li><strong>Fixed nodes, fixed connections, variable parameters</strong> (Fixed-Node layout).</li>
  <li><strong>Fixed nodes, variable connections, variable parameters</strong>.</li>
  <li><strong>Variable nodes, variable connections, variable parameters</strong>.</li>
</ol>

<p>Each phase progressively increases the complexity of the AI agent, with the first phase being the simplest.</p>

<blockquote>
  <p>Josh — 01/07/2024 at 09:20</p>
</blockquote>

<blockquote>
  <p>the node graph editor is a good chunk of work, and then the hard part is genetic recombination of node graphs
your first prototype should probably use a fixed node layout</p>
</blockquote>

<blockquote>
  <p>you can absolutely implement one that allows the ML to add or delete nodes, but then you need rules for handling recombination and crossover</p>
</blockquote>

<blockquote>
  <p>changing the counts and connections is simple enough, but leads to problems when cross-breeding two specimens with different graph structures</p>
</blockquote>

<blockquote>
  <p>in the end, the AI should generate the whole graph
but it’s totally okay if you don’t get that far</p>
</blockquote>

<blockquote>
  <p>I am pushing for a genetic algorithm
you have not heard the end of genetic algorithms
they are old school but will once again revolutionize artificial intelligence in the next ten years
in particular they will become important to avoid overfitting in DNN training</p>
</blockquote>

<blockquote>
  <p>their importance is about to skyrocket</p>
</blockquote>

<blockquote>
  <p>genetic algorithms are due for a Renaissance, is what I’m saying</p>
</blockquote>

<h2 id="visualshader-class"><code class="language-plaintext highlighter-rouge">VisualShader</code> Class</h2>

<p>Now that we’ve covered the theory, let’s discuss the important class I have been working on over the past few weeks.</p>

<p>The <strong>VisualShader</strong> class encompasses the graph and its core functionalities. As Josh mentioned, these primary functionalities should ideally be included in the Protobuf message; however, I prefer to complete the implementation first and then refactor as needed. The <strong>Graph</strong> is structured simply, as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Graph</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">VisualShader</span><span class="o">::</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VisualShader</span><span class="o">::</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connections</span><span class="p">;</span>
<span class="p">}</span> <span class="n">graph</span><span class="p">;</span></code></pre></figure>

<p>The main functions within the <strong>VisualShader</strong> class are as follows:</p>

<ul>
  <li><strong>generate_shader</strong></li>
  <li><strong>generate_preview_shader</strong></li>
  <li><strong>generate_shader_for_each_node</strong></li>
</ul>

<p>The <strong>generate_shader</strong> function serves as the primary entry point for users. It contains a recursive algorithm that traverses the graph, starting from the output node. The <strong>Output</strong> node is a special node in the graph; it cannot be added or deleted and has an ID of 0.</p>

<p>The <strong>generate_preview_shader</strong> function is a simplified version of <strong>generate_shader</strong>. It is designed to generate the shader for the preview window, which will utilize ENIGMA’s Graphics System for rendering. This function is essential because it can generate the shader starting from any node in the graph.</p>

<p>Both <strong>generate_shader</strong> and <strong>generate_preview_shader</strong> will call the <strong>generate_shader_for_each_node</strong> function. This function is invoked for each node in the graph, generating the shader for that node and its children.</p>

<p>Now, let’s delve into the <strong>generate_shader</strong> function. To generate the shader code accurately, we first need to separate the code into three distinct parts:</p>

<ul>
  <li><strong>Global code</strong></li>
  <li><strong>Global code for each node</strong></li>
  <li><strong>Local code for each node</strong></li>
</ul>

<p>The <strong>global code</strong> must be generated only once. Therefore, if a node is used multiple times in the graph, we want to avoid generating the code for it repeatedly. The <strong>global code for each node</strong> pertains to the code generated for each node in the graph, while the <strong>local code for each node</strong> is specific to each node and its children.</p>

<p>To facilitate this, I created multiple buffers at the start of the function to store the code and pass them by reference to the recursive function.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">global_code</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">global_code_per_node</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">shader_code</span><span class="p">;</span></code></pre></figure>

<p>Another important aspect to mention is that the connections are stored within a <code class="language-plaintext highlighter-rouge">std::vector</code>. While this approach provides flexibility, it can increase the time complexity of the algorithm. However, this issue can be addressed using the following snippet:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ConnectionKey</span><span class="p">,</span> <span class="k">const</span> <span class="n">Connection</span><span class="o">*&gt;</span> <span class="n">input_connections</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ConnectionKey</span><span class="p">,</span> <span class="k">const</span> <span class="n">Connection</span><span class="o">*&gt;</span> <span class="n">output_connections</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">func_code</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">processed</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Connection</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">connections</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ConnectionKey</span> <span class="n">from_key</span><span class="p">;</span>
    <span class="n">from_key</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">from_node</span><span class="p">;</span>
    <span class="n">from_key</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">from_port</span><span class="p">;</span>

    <span class="n">output_connections</span><span class="p">[</span><span class="n">from_key</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

    <span class="n">ConnectionKey</span> <span class="n">to_key</span><span class="p">;</span>
    <span class="n">to_key</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">to_node</span><span class="p">;</span>
    <span class="n">to_key</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">to_port</span><span class="p">;</span>

    <span class="n">input_connections</span><span class="p">[</span><span class="n">to_key</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now, we can call the <strong>generate_shader_for_each_node</strong> function for the output node. This function will be executed recursively for each node in the graph. We begin by checking the inputs of the current node until we reach a node that has no inputs (the input node). Once we identify such a node, we proceed to generate the code for that node and its children.</p>

<p>In the <strong>VisualShaderTest.Test_generate_shader</strong> test, the <strong>generate_shader</strong> function took <strong>160 μs</strong> to generate the shader for the graph. While I believe there is room for improvement in this time, my priority is to ensure that no time is wasted during this process.</p>

<p>The <strong>ConnectionKey</strong> union is defined as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">union</span> <span class="n">ConnectionKey</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">FragmentedKey</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">node</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">port</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">f_key</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">.</span><span class="n">key</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p><img src="/gsoc24-blog/assets/connection-key-theory.png" alt="Connection Key Theory" /></p>

<p>This union will serve as the key for each <strong>Connection</strong> object in a <code class="language-plaintext highlighter-rouge">std::map</code>. The key is a 64-bit integer, with the first 32 bits representing the node ID and the second 32 bits representing the port ID. This structure allows us to efficiently search for connections in constant time, <strong>O(1)</strong>, using just the node ID and port ID.</p>

<h2 id="changing-the-structure-of-the-project">Changing The Structure Of The Project</h2>

<p>After discussing with Greg, I learned that anything within the <code class="language-plaintext highlighter-rouge">ENIGMAsystem/</code> directory must provide user-facing functions, specifically the EDL functions that game developers will use. Since the <strong>VisualShader</strong> class is intended for use by RGM only, I followed Josh’s recommendation and moved the class to <code class="language-plaintext highlighter-rouge">ENIGMAsystem/shared/ResourceTransformations/VisualShader/</code>.</p>

<p>Additionally, the tests for this class should be part of the <code class="language-plaintext highlighter-rouge">test-runner</code> instead of <code class="language-plaintext highlighter-rouge">emake-tests</code>, so I will relocate them to <code class="language-plaintext highlighter-rouge">CommandLine/testing/Tests/</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
enigma-dev
├── ...
├── CommandLine
│   ├── ...
│   └── testing
│       ├── ...
│       └── Tests
│           ├── ...
│           ├── visual_shader_tests.cpp
│           └── visual_shader_nodes_tests.cpp
│
└── shared
    └── ResourceTransformations
        └── VisualShader
            ├── ...
            ├── visual_shader.h
            ├── visual_shader.cpp
            ├── visual_shader_nodes.h
            └── visual_shader_nodes.cpp

</code></pre></div></div>


  </div></div>

    </section>
    <footer class="">
      <ul class="social about-footer "><a href="https://github.com/k0T0z" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a></ul><p class="about-footer ">&copy;
        2025</p><div class="about-footer ">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/gsoc24-blog/assets/js/darkmode.js"></script>
  
  <script src="/gsoc24-blog/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/gsoc24-blog/assets/js/search.js"></script>
  
</body>

</html>
