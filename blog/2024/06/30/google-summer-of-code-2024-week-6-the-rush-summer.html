<!DOCTYPE html>
<html lang="">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/gsoc24-blog/assets/css/style.css">
<title>Google Summer of Code 2024 Week 6: The Rush Summer</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Google Summer of Code 2024 Week 6: The Rush Summer | k0T0z</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Google Summer of Code 2024 Week 6: The Rush Summer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning." />
<meta property="og:description" content="This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning." />
<link rel="canonical" href="https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html" />
<meta property="og:url" content="https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html" />
<meta property="og:site_name" content="k0T0z" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-06-30T21:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Google Summer of Code 2024 Week 6: The Rush Summer" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-06-30T21:00:00+00:00","datePublished":"2024-06-30T21:00:00+00:00","description":"This blog post is related to my Google Summer of Code 2024 project: Procedural Fragment Shader Generation Using Classic Machine Learning.","headline":"Google Summer of Code 2024 Week 6: The Rush Summer","mainEntityOfPage":{"@type":"WebPage","@id":"https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html"},"url":"https://k0t0z.github.io/gsoc24-blog//gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html"}</script>
<!-- End Jekyll SEO tag -->


<script type="text/javascript" src="/gsoc24-blog/assets/js/darkmode.js"></script>

</head><body>
  <main class="container">
    <section class="about">
      <div class="about-header ">
      <div class="about-title">
      <a href="/gsoc24-blog/">
        
        <img src="/gsoc24-blog/assets/portfolio.png" alt="Saif Kandil" />
        
      </a>
      <h2 id="title">
        <a href="/gsoc24-blog/">Saif Kandil</a>
      </h2>
      </div><p class="tagline">Just a place for me to dump my thoughts about my Google Summer of Code 2024 project</p></div>
      
      <ul class="social about-footer "><a href="https://github.com/k0T0z" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a></ul><p class="about-footer ">&copy;
        2024</p><div class="about-footer ">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/gsoc24-blog/blog/2024/06/30/google-summer-of-code-2024-week-6-the-rush-summer.html">
    <h2 class="post-title">Google Summer of Code 2024 Week 6: The Rush Summer</h2>
  </a>
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Jun 30, 2024</div><ul class="post-categories"><li>blog</li></ul></div>
  <div class="post">
    <p>This blog post is related to my Google Summer of Code 2024 project: <a href="https://summerofcode.withgoogle.com/programs/2024/projects/wYTZuQbA">Procedural Fragment Shader Generation Using Classic Machine Learning</a>.</p>

<h2 id="enigma-and-google-protobuf">ENIGMA and Google Protobuf</h2>

<p>ENIGMA depends on Protobuf is many things. RGM is considered to be a MVC application or Model View Controller. Every UI component of RGM is part of a proto message. This is also how ENIGMA serializes/deserializes its project files.</p>

<blockquote>
  <p>Josh — 01/07/2024 at 08:14</p>
</blockquote>

<blockquote>
  <p>you can eliminate a lot of that boilerplate using proto, @Saif
in fact, I recommend it, as you’ll need proto on hand to serialize to EGM etc</p>
</blockquote>

<blockquote>
  <p>add_node is a great example
of boilerplate, I mean; literally that is a function that protobuf would generate
check out the other resource messages
just search RGM for proto files</p>
</blockquote>

<blockquote>
  <p>Josh — 01/07/2024 at 09:25</p>
</blockquote>

<blockquote>
  <p>I suspect some of what I’ve written will still be necessary, but I suggest you try writing these node classes as protobuf messages and see where that gets you</p>
</blockquote>

<blockquote>
  <p>proto should save you a lot of effort here</p>
</blockquote>

<blockquote>
  <p>proto is just what C++ classes should look like</p>
</blockquote>

<blockquote>
  <p>well, sorry; as a storage layer, proto is certainly not what C++ classes should look like
but in terms of the features that a proto message offers….
there is absolutely no reason a modern programming language should not offer these features for its classes
proto just lets you do things like serialize and deserialize, use reflection, etc</p>
</blockquote>

<h2 id="the-ai-agent-phases">The AI Agent Phases</h2>

<p>When reaching the ML part, there are 3 main phases that we need to consider:</p>

<ol>
  <li>Fixed nodes, fixed connections, variable parameters (Fixed-Node layout).</li>
  <li>Fixed nodes, variable connections, variable parameters.</li>
  <li>Variable nodes, variable connections, variable parameters.</li>
</ol>

<p>Each phase should increase the complexity of the AI agent. The first phase is the easiest one.</p>

<blockquote>
  <p>Josh — 01/07/2024 at 09:20</p>
</blockquote>

<blockquote>
  <p>the node graph editor is a good chunk of work, and then the hard part is genetic recombination of node graphs
your first prototype should probably use a fixed node layout</p>
</blockquote>

<blockquote>
  <p>you can absolutely implement one that allows the ML to add or delete nodes, but then you need rules for handling recombination and crossover</p>
</blockquote>

<blockquote>
  <p>changing the counts and connections is simple enough, but leads to problems when cross-breeding two specimens with different graph structures</p>
</blockquote>

<blockquote>
  <p>in the end, the AI should generate the whole graph
but it’s totally okay if you don’t get that far</p>
</blockquote>

<blockquote>
  <p>I am pushing for a genetic algorithm
you have not heard the end of genetic algorithms
they are old school but will once again revolutionize artificial intelligence in the next ten years
in particular they will become important to avoid overfitting in DNN training</p>
</blockquote>

<blockquote>
  <p>their importance is about to skyrocket</p>
</blockquote>

<blockquote>
  <p>genetic algorithms are due for a Renaissance, is what I’m saying</p>
</blockquote>

<h2 id="visualshader-class"><code class="language-plaintext highlighter-rouge">VisualShader</code> Class</h2>

<p>Now enough theory, let’s talk about the important class I was working on during the past weeks.</p>

<p>The VisualShader class contains the graph and its main functionalities. As Josh said, these main functionalities should be part of the proto message, however, I like finishing it out and then refactoring. The <code class="language-plaintext highlighter-rouge">Graph</code> is a simple struct as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Graph</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">VisualShader</span><span class="o">::</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VisualShader</span><span class="o">::</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connections</span><span class="p">;</span>
<span class="p">}</span> <span class="n">graph</span><span class="p">;</span></code></pre></figure>

<p>The main functions are:</p>

<ul>
  <li>generate_shader</li>
  <li>generate_preview_shader</li>
  <li>generate_shader_for_each_node</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">generate_shader</code> function is the main function that will be called by the user. It will contains a recursively algorithm that will go through the graph starting from the output node. The <code class="language-plaintext highlighter-rouge">Output</code> node is the special node in the graph as it can’t be added or deleted. It has the id of 0.</p>

<p>The <code class="language-plaintext highlighter-rouge">generate_preview_shader</code> is a simplified version of the <code class="language-plaintext highlighter-rouge">generate_shader</code> function. It will be used to generate the shader for the preview window. The preview window is expected to use ENIGMA’s Graphics System to render the shader. It is necessary because it can generate the shader starting from any node in the graph.</p>

<p>Both functions will call the <code class="language-plaintext highlighter-rouge">generate_shader_for_each_node</code> function. This function will be called for each node in the graph. It will generate the shader for the node and its children.</p>

<p>Now let’s walk through the <code class="language-plaintext highlighter-rouge">generate_shader</code> function. In order to generate the shader code correctly, first we have to separate the shader code into 3 parts:</p>
<ul>
  <li>global code</li>
  <li>global code for each node</li>
  <li>local code for each node</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">global code</code> must be generated once. So if we have a node that is used multiple times in the graph, we don’t want to generate the code for it multiple times. The <code class="language-plaintext highlighter-rouge">global code for each node</code> is the code that is generated for each node in the graph. The <code class="language-plaintext highlighter-rouge">local code for each node</code> is the code that is generated for each node and its children.</p>

<p>That’s why at the start of the function I created multiple buffers to store the code and send them by reference to the recursive function.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">global_code</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">global_code_per_node</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">shader_code</span><span class="p">;</span></code></pre></figure>

<p>Another important step that I need to mention is that the connections are stored inside <code class="language-plaintext highlighter-rouge">std::vector</code>. This will increase the time complexity of the algorithm. This can be solved by the following snippet:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ConnectionKey</span><span class="p">,</span> <span class="k">const</span> <span class="n">Connection</span><span class="o">*&gt;</span> <span class="n">input_connections</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ConnectionKey</span><span class="p">,</span> <span class="k">const</span> <span class="n">Connection</span><span class="o">*&gt;</span> <span class="n">output_connections</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">func_code</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">processed</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Connection</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">connections</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ConnectionKey</span> <span class="n">from_key</span><span class="p">;</span>
    <span class="n">from_key</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">from_node</span><span class="p">;</span>
    <span class="n">from_key</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">from_port</span><span class="p">;</span>

    <span class="n">output_connections</span><span class="p">[</span><span class="n">from_key</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

    <span class="n">ConnectionKey</span> <span class="n">to_key</span><span class="p">;</span>
    <span class="n">to_key</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">to_node</span><span class="p">;</span>
    <span class="n">to_key</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">to_port</span><span class="p">;</span>

    <span class="n">input_connections</span><span class="p">[</span><span class="n">to_key</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now, we can call <code class="language-plaintext highlighter-rouge">generate_shader_for_each_node</code> function for the output node. The function will be called recursively for each node in the graph. First we check the inputs of the current node until we reach a node that has no inputs (the input node). Then we generate the code for the node and its children.</p>

<p>The <code class="language-plaintext highlighter-rouge">generate_shader</code> function took <code class="language-plaintext highlighter-rouge">160 μs</code> to generate the shader for the graph in the <code class="language-plaintext highlighter-rouge">VisualShaderTest.Test_generate_shader</code> test. I can improve this time however, as I said, I want to waste ZERO time here.</p>

<p>The <code class="language-plaintext highlighter-rouge">ConnectionKey</code> union is defined as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">union</span> <span class="n">ConnectionKey</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">FragmentedKey</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">node</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">port</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">f_key</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">.</span><span class="n">key</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p><img src="/gsoc24-blog/assets/connection-key-theory.png" alt="Connection Key Theory" /></p>

<p>This union will be used as a key for each <code class="language-plaintext highlighter-rouge">Connection</code> object in <code class="language-plaintext highlighter-rouge">std::map</code>. The key is a 64-bit integer that contains the node id in the first 32 bits and the port id in the second 32 bits. This will allow us to search for the connection in <code class="language-plaintext highlighter-rouge">O(1)</code> time complexity using only a node id and a port id.</p>

<h2 id="changing-the-structure-of-the-project">Changing The Structure Of The Project</h2>

<p>After talking with Greg, I found out that anything inside <code class="language-plaintext highlighter-rouge">ENIGMAsystem/</code> must provide user functions. The EDL functions that the game developer will use. The <code class="language-plaintext highlighter-rouge">VisualShader</code> class is actually a class that will be used by RGM only. So, I moved the class to <code class="language-plaintext highlighter-rouge">ENIGMAsystem/shared/ResourceTransformations/VisualShader/</code> as Josh recommended.</p>

<p>The tests as well must be part of <code class="language-plaintext highlighter-rouge">test-runner</code> not <code class="language-plaintext highlighter-rouge">emake-tests</code>. I will move them to <code class="language-plaintext highlighter-rouge">CommandLine/testing/Tests/</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
enigma-dev
├── ...
├── CommandLine
│   ├── ...
│   └── testing
│       ├── ...
│       └── Tests
│           ├── ...
│           ├── visual_shader_tests.cpp
│           └── visual_shader_nodes_tests.cpp
│
└── shared
    └── ResourceTransformations
        └── VisualShader
            ├── ...
            ├── visual_shader.h
            ├── visual_shader.cpp
            ├── visual_shader_nodes.h
            └── visual_shader_nodes.cpp

</code></pre></div></div>


  </div></div>

    </section>
    <footer class="">
      <ul class="social about-footer "><a href="https://github.com/k0T0z" target="_blank">
          <li>
            <i class="icon-github-circled"></i>
          </li>
        </a></ul><p class="about-footer ">&copy;
        2024</p><div class="about-footer ">
        <p>Dark Mode
          <i class="icon-moon"></i>
          <label class="switch">
            <input type="checkbox" class="dark-mode-toggle">
            <span class="slider round" onclick="toggleDarkMode()"></span>
          </label>
        </p>
      </div>
    </footer>
  </main>
  
  <script type="text/javascript" src="/gsoc24-blog/assets/js/darkmode.js"></script>
  
  <script src="/gsoc24-blog/assets/js/simple-jekyll-search.min.js"></script>
  <script src="/gsoc24-blog/assets/js/search.js"></script>
  
</body>

</html>
